# 偏函数(Partial function)

"""
# python的functools模块提供了很多有用的功能，其中一个就是偏函数(Partial function)。
# 要注意，这里的偏函数和数学意义上的偏函数不一样。

# 在介绍函数参数的时候，提到过，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。
"""''

# 举例：int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：
print(int('12345'))  # 12345

# 但int()函数还是提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：
print(int('12345', base=8))  # 5349
print(int('12345', 16))  # 74565

# 假设要转化大量的二进制字符串，每次都传入int(x, base=2)非常麻烦
# 可以定义一个int2()函数，默认吧base=2传进去：
def int2(x, base=2):
    return int(x, base)

# 这样，转换二进制就方便了很多
print(int2('100000'))  # 32
print(int2('101010'))  # 42

# functools.portial就是帮助我们创建一个偏函数的，不需要自己定义int2()，可以直接用下面的代码创建一个新的函数int2：
import functools
int2 = functools.partial(int, base=2)
# 输出结果同上

"""
# 所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），
# 返回一个新的函数，调用这个新函数会更简单。

# 注意到上面新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：
>>> int2('1000000', base=10)
# 1000000

# 最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：
int2 = functools.partial(int, base=2)

# 实际上固定了int()函数当关键字base，也就是：
int2('10010')

# 相当于：
kw = {'base': 2}
int('10010', **kw)

# 当传入：
max2 = functools.portial(max, 10)

# 实际上会把10作为*args当一部分自动加到左边，也就是：
max2(5, 6, 7)

# 相当于：
args = (10, 5, 6, 7)
max(*args)
# 结果为10
"""

# 小结：
# 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，
# 这个新函数可以固定住原函数的部分参数，从而在调用时更简单。

"""
# 下面是评论区的一个总结：
# 偏函数可以简化参数操作。
# 当函数的某个参数是我们可以提前获知的，那我们就可以将它固定住！

# 举例:
def mod(x, y=2):
    # 返回True或False
    return x % y == 0
    
# 假设我们要计算和3取余，如果不使用partial()函数，那么我们每次调用mod()函数时，都要写y = 3
mod(4, y=3)
mod(6, y=3)

# 使用partial()函数
from functools import partial
mod_3 = partial(mod, y=3)
mod_3(4)
mod_3(6)

# 使用偏函数可以让我们减少填写参数的步骤，也可以使代码更加简洁。
# 有的人说那我重新定义一个不也可以吗？使用C&V操作无视函数体代码量多少，再定义一个。

# 当然可以这样做，但这样会使得源码变得臃肿，试想有两个函数，它俩的不同点就是默认参数值不一样。。。。
# 总之，使用偏函数，可以使你的代码和操作更加简洁。
"""